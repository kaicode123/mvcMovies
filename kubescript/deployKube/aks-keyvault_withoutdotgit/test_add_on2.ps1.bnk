echo "Setting up the variables..."
$suffix = "demof01111"
$subscriptionId = (az account show | ConvertFrom-Json).id

echo $subscriptionId

$tenantId = (az account show | ConvertFrom-Json).tenantId
$location = "southeastasia" # "uksouth" # 
$resourceGroupName = "rg-" + $suffix

## Kai edited --------------------
$vnetName = "vnet-" + $suffix
$vnetAddressPrefix = "10.10.0.0/16"


# the following subnet will be used fro both cluster and pods
$clusterSubnetName = "clusterSubnet-" + $suffix
$clusterSubnetAddress = "10.10.10.0/24"

$virtualNodeSubnetName = "virtualNodeSubnet-" + $suffix
$virtualNodeSubnetAddress = "10.10.11.0/24"

$dockerBridgeAddress = "172.17.0.1/16"
$dnsServiceIP = "10.2.0.10"
$serviceCIDR = "10.2.0.0/24"
##---------------------------------



$aksName = "aks-" + $suffix
$aksVersion = "1.18.6"
$keyVaultName = "keyvaultaks" + $suffix
$secret1Name = "DatabaseLogin"
$secret2Name = "DatabasePassword"
$secret1Alias = "DATABASE_LOGIN"
$secret2Alias = "DATABASE_PASSWORD" 
$identityName = "identity-aks-kv"
$identitySelector = "azure-kv"
$secretProviderClassName = "secret-provider-kv"
$acrName = "acrforaks" + $suffix
$isAKSWithManagedIdentity = "true"

echo "Creating Resource Group..."
$resourceGroup = az group create -n $resourceGroupName -l $location | ConvertFrom-Json



echo "Creating ACR..."
$acr = az acr create --resource-group $resourceGroupName --name $acrName --sku Basic | ConvertFrom-Json
az acr login -n $acrName --expose-token



# kai edited - create vnet
#az network vnet create -g $resourceGroupName -n $vnetName
az network vnet create -g $resourceGroupName -n  $vnetName --address-prefix $vnetAddressPrefix --subnet-name $clusterSubnetName --subnet-prefix $clusterSubnetAddress



# kai edited - create subnet for vnet created above
#az network vnet subnet create -g $resourceGroupName --vnet-name $vnetName -n $subnetName --address-prefixes 10.10.10.0/24

#kai edited - get the subnet resource ID
$subnetId = az network vnet subnet list --resource-group $resourceGroupName --vnet-name $vnetName --query "[0].id" --output tsv

echo $subnetId
az provider register --namespace Microsoft.ContainerInstance

echo "Creating AKS..."
If ($isAKSWithManagedIdentity -eq "true") {
  echo "Creating AKS cluster with Managed Identity..."
 
#Kai edited -- to enable CNI
 $aks = az aks create -n $aksName -g $resourceGroupName --kubernetes-version $aksVersion --node-count 1 --attach-acr $acrName --enable-managed-identity --network-plugin azure --vnet-subnet-id $subnetId --docker-bridge-address $dockerBridgeAddress --dns-service-ip $dnsServiceIP --service-cidr $serviceCIDR | ConvertFrom-Json
} Else {
  echo "Creating AKS cluster with Service Principal..."
  $aks = az aks create -n $aksName -g $resourceGroupName --kubernetes-version $aksVersion --node-count 1 --attach-acr $acrName | ConvertFrom-Json
}
# retrieve existing AKS
$aks = (az aks show -n $aksName -g $resourceGroupName | ConvertFrom-Json)


echo $aks

az network vnet subnet create --resource-group $resourceGroupName --vnet-name $vnetName --name $virtualNodeSubnetName --address-prefixes $virtualNodeSubnetAddress
#az role assignment create --role "Contributor" --assignee $aks.identityProfile.kubeletidentity.clientId --scope /subscriptions/$subscriptionId/resourcegroups/$($resourceGroupName)
az aks enable-addons --resource-group $resourceGroupName  --name $aksName --addons virtual-node --subnet-name $virtualNodeSubnetName

$existingIdentity2 = az resource list -g $aks.nodeResourceGroup --query "[?contains(name, 'aciconnectorlinux')]"  | ConvertFrom-Json
$identity2 = az identity show -n $existingIdentity2.name -g $existingIdentity2.resourceGroup | ConvertFrom-Json


echo "Assigning Contributor Role to new Identity for Resource Group that contain vNET..."
az role assignment create --role "Contributor" --assignee $identity2.principalId --scope /subscriptions/$subscriptionId/resourcegroups/$($resourceGroupName)


#echo "Restarting vmss ..."
#$vmss = az vmss list --resource-group $aks.nodeResourceGroup | ConvertFrom-Json
#az vmss restart --name $vmss.name --resource-group $vmss.resourcegroup

echo "Connecting/authenticating to AKS..."
az aks get-credentials -n $aksName -g $resourceGroupName --overwrite-existing


<#

echo "Creating Key Vault..."
$keyVault = az keyvault create -n $keyVaultName -g $resourceGroupName -l $location --enable-soft-delete true --retention-days 7 | ConvertFrom-Json

echo "Creating Secrets in Key Vault..."
az keyvault secret set --name $secret1Name --value "Houssem" --vault-name $keyVaultName
az keyvault secret set --name $secret2Name --value "P@ssword123456" --vault-name $keyVaultName

echo "Installing Secrets Store CSI Driver using Helm..."
kubectl create ns csi-driver
echo "Installing Secrets Store CSI Driver with Azure Key Vault Provider..."
helm repo add csi-secrets-store-provider-azure https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/charts
helm install csi-azure csi-secrets-store-provider-azure/csi-secrets-store-provider-azure --namespace csi-driver
sleep 2
kubectl get pods -n csi-driver

echo "Using the Azure Key Vault Provider..."
$secretProviderKV = @"
apiVersion: secrets-store.csi.x-k8s.io/v1alpha1
kind: SecretProviderClass
metadata:
  name: $($secretProviderClassName)
spec:
  provider: azure
  parameters:
    usePodIdentity: "true"
    useVMManagedIdentity: "false"
    userAssignedIdentityID: ""
    keyvaultName: $keyVaultName
    cloudName: AzurePublicCloud
    objects:  |
      array:
        - |
          objectName: $secret1Name
          objectAlias: $secret1Alias
          objectType: secret
          objectVersion: ""
        - |
          objectName: $secret2Name
          objectAlias: $secret2Alias
          objectType: secret
          objectVersion: ""
    resourceGroup: $resourceGroupName
    subscriptionId: $subscriptionId
    tenantId: $tenantId
"@
$secretProviderKV | kubectl create -f -

# Run the following 2 commands only if using AKS with Managed Identity
If ($isAKSWithManagedIdentity -eq "true") {
  az role assignment create --role "Managed Identity Operator" --assignee $aks.identityProfile.kubeletidentity.clientId --scope /subscriptions/$subscriptionId/resourcegroups/$($aks.nodeResourceGroup)
  az role assignment create --role "Virtual Machine Contributor" --assignee $aks.identityProfile.kubeletidentity.clientId --scope /subscriptions/$subscriptionId/resourcegroups/$($aks.nodeResourceGroup)
  # If user-assigned identities that are not within the cluster resource group
  # az role assignment create --role "Managed Identity Operator" --assignee $aks.identityProfile.kubeletidentity.clientId --scope /subscriptions/$subscriptionId/resourcegroups/$resourceGroupName
}

echo "Installing AAD Pod Identity into AKS..."
helm repo add aad-pod-identity https://raw.githubusercontent.com/Azure/aad-pod-identity/master/charts
helm install pod-identity aad-pod-identity/aad-pod-identity
# kubectl apply -f https://raw.githubusercontent.com/Azure/aad-pod-identity/master/deploy/infra/deployment-rbac.yaml
kubectl get pods

# If using AKS with Managed Identity, retrieve the existing Identity
If ($isAKSWithManagedIdentity -eq "true") {
  echo "Retrieving the existing Azure Identity..."
  while($existingIdentity -eq $null) {
    echo "Retrying until Identity is ready..."
    $existingIdentity = az resource list -g $aks.nodeResourceGroup --query "[?contains(type, 'Microsoft.ManagedIdentity/userAssignedIdentities')]"  | ConvertFrom-Json
  }
  $identity = az identity show -n $existingIdentity.name -g $existingIdentity.resourceGroup | ConvertFrom-Json
} Else {
  # If using AKS with Service Principal, create new Identity
  echo "Creating an Azure Identity..."
  $identity = az identity create -g $resourceGroupName -n $identityName | ConvertFrom-Json
}

echo "Assigning Reader Role to new Identity for Key Vault..."
az role assignment create --role "Reader" --assignee $identity.principalId --scope $keyVault.id

# Run the following command only if using AKS with Service Principal
If ($isAKSWithManagedIdentity -eq "false") {
  echo "Providing required permissions for MIC..."
  az role assignment create --role "Managed Identity Operator" --assignee $aks.servicePrincipalProfile.clientId --scope $identity.id
}

echo "Setting policy to access secrets in Key Vault..."
az keyvault set-policy -n $keyVaultName --secret-permissions get --spn $identity.clientId

echo "Adding AzureIdentity and AzureIdentityBinding..."
$aadPodIdentityAndBinding = @"
apiVersion: aadpodidentity.k8s.io/v1
kind: AzureIdentity
metadata:
  name: $($identityName)
spec:
  type: 0
  resourceID: $($identity.id)
  clientID: $($identity.clientId)
---
apiVersion: aadpodidentity.k8s.io/v1
kind: AzureIdentityBinding
metadata:
  name: $($identityName)-binding
spec:
  azureIdentity: $($identityName)
  selector: $($identitySelector)
"@
$aadPodIdentityAndBinding | kubectl apply -f -

echo "Deploying a Nginx Pod for testing..."
$nginxPod = @"
kind: Pod
apiVersion: v1
metadata:
  name: nginx-secrets-store
  labels:
    aadpodidbinding: $($identitySelector)
spec:
  containers:
    - name: nginx
      image: nginx
      volumeMounts:
      - name: secrets-store-inline
        mountPath: "/mnt/secrets-store"
        readOnly: true
  volumes:
    - name: secrets-store-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: $($secretProviderClassName)
"@
$nginxPod | kubectl apply -f -

sleep 20
kubectl get pods

echo "Validating the pod has access to the secrets from Key Vault..."
kubectl exec -it nginx-secrets-store -- ls /mnt/secrets-store/
kubectl exec -it nginx-secrets-store -- cat /mnt/secrets-store/DATABASE_LOGIN
kubectl exec -it nginx-secrets-store -- cat /mnt/secrets-store/$secret1Alias
kubectl exec -it nginx-secrets-store -- cat /mnt/secrets-store/DATABASE_PASSWORD
kubectl exec -it nginx-secrets-store -- cat /mnt/secrets-store/$secret2Alias

az provider register --namespace Microsoft.ContainerInstance
az aks enable-addons --resource-group $resourceGroupName  --name $aksName --addons virtual-node --subnet-name $subnetId

# Testing ACR and AKS authN
# az acr build -t productsstore:0.1 -r $acrName .\ProductsStoreOnKubernetes\MvcApp\
# kubectl run --image=$acrName.azurecr.io/productsstore:0.1 prodstore --generator=run-pod/v1

# clean up resources 
# az keyvault purge -n $keyVaultName
# az group delete --no-wait --yes -n $resourceGroupName
# az group delete --no-wait --yes -n $aks.nodeResourceGroup
#>
